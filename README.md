# log_analyzer
Кейс с хакатона "Цифровой суверенитет 2023" 

Данный кейс предоставлялся компанией Sitronics. ТЗ указано в файле "разработка_sitronics_1".

# Комментарии к программе:

Данная программа позволяет анализировать предоставленные логи в 3 режимах:
1. Выбирает из входного файла лога те строки, в которых есть вхождение одного или нескольких ключевых слов и сохраняет выбранные строки лога в выходной файл.
2. Выбирает из входного файла лога те строки, в которых есть вхождение одного или нескольких ключевых слов и сохраняет выбранные строки лога в несколько выходных файлов, объединяя их по значению уникального идентификатора. В базовом варианте решения, уникальный идентификатор связан с ключевым словом через знак минуса. В расширенном варианте решения положение уникального идентификатора в строке задается с помощью шаблона.
3. Выбирает из входного файла лога те строки, в которых есть вхождение одного или нескольких ключевых слов и сохраняет выбранные строки лога в выходной файл. При сохранении к строкам применяется шаблон, с помощью которого можно вырезать из строки необходимую для анализа часть.
# Комментарии к переменным передаваемых в функцию:
**'input_file'** – путь к файлу, из которого будут браться логи.  
**'keywords'** – одно или несколько ключевых слов.  
**'-o', '--output_file'** – путь к файлу, в который будут записываться подходящие логи.  
**'-g', '--group_by_id'** – переменная для работы программы в 2 режиме, если переменная передается – программа выполняет работу во 2 режиме (группировка и распределение подходящих в разные файлы согласно указанному шаблону).  
**'-i', '--id_pattern'** – собственно сам шаблон группировки для работы во 2 режиме.  
**'-t', '--template'** – переменная, в которой указывается шаблон для работы программы в 3 режиме (применяется шаблон, с помощью которого можно вырезать из строки необходимую для анализа часть).
# Работа в режиме 1
Для работы в 1 режиме достаточно указать 'input_file', 'keywords' и '-o', '--output_file', после чего программа построчно пройдет по всему файлу, выберет строки, в которых есть указанные ключевые слова и запишет подходящие строки в '--output_file'.  
**Пример:**
parser.py C:\Users\yurch\Desktop\CTF\log1.txt XIMSS CALLLEG -o C:\Users\yurch\Desktop\CTF\xx.txt
Отбираются все строки с ключевыми словами «XIMSS CALLLEG».
# Работа в режиме 2
Для работы во 2 режиме нужно указать 'input_file', 'keywords' и '-o', '--output_file', '--group_by_id', '--id_pattern', после чего сначала отбираются все строки содержащие ключевые слова, далее при помощи defaultdict(list) создаем словарь в который далее будем группировать по указанному шаблону отобранные выше строки. И потом уже сохраняем сгруппированные строки в разные файлы.  
**Пример:**
parser.py C:\Users\yurch\Desktop\CTF\log1.txt CALLLEG -g -i "CALLLEG-\d+" -o C:\Users\yurch\Desktop\CTF\out
Отбираются все строки с ключевым словом «CALLLEG», далее они группируются и записываются в разные файлы согласно шаблону "CALLLEG-\d+» (CALLLEG-000022, CALLLEG-000024 и т.д.)
# Работа в режиме 3
Для работы в 3 режиме нужно указать 'input_file', 'keywords' и '-o', '--output_file' и '-t', '--template', после чего сначала отбираются все строки содержащие ключевые слова, далее из них вычленяются указанные в шаблоне данные.  
**Пример:**
parser.py C:\Users\yurch\Desktop\CTF\log1.txt HTTPU -t "\(.*?\) " -o C:\Users\yurch\Desktop\CTF\test.txt
Отбираются все строки с ключевым словом «HTTPU», после чего из отобранных строк выбираются данные подходящие под шаблон «\(.*?\)» (выбираются данные заключенные между круглыми скобками).
